---
title: "Transformation Chains"
description: "Guide to creating and managing complex transformation chains in Gulp"
---

# Transformation Chains

Gulp allows you to create complex data processing pipelines by chaining multiple transformations together. This guide covers how to create, optimize, and manage transformation chains.

## Basic Concepts

A transformation chain is a sequence of operations applied to your data stream:

```yaml
transformations:
  - id: "enrichStream"
    type: "enrich"
    input: "sourceStream"
    enrichmentConfig:
      fields:
        - name: "category"
          lookupTable: "categories"
          keyField: "productId"
  
  - id: "filteredStream"
    type: "filter"
    input: "enrichStream"
    filterRule:
      field: "value"
      operator: "gt"
      value: 0.0
  
  - id: "aggregatedStream"
    type: "window"
    input: "filteredStream"
    windowConfig:
      windowType: "tumbling"
      windowSize: 3600
      timeUnit: "SECONDS"
      aggregateRules:
        - name: "totalValue"
          field: "value"
          operation: "sum"
          fieldType: "double"
```

## Transformation Types

### 1. Filter Transformations

Filter records based on conditions:

```yaml
transformations:
  - id: "highValueTransactions"
    type: "filter"
    input: "sourceStream"
    filterRule:
      type: "composite"
      operator: "and"
      conditions:
        - field: "value"
          operator: "gt"
          value: 1000.0
        - field: "status"
          operator: "eq"
          value: "completed"
```

### 2. Map Transformations

Transform individual fields:

```yaml
transformations:
  - id: "enrichedStream"
    type: "map"
    input: "sourceStream"
    mappings:
      - targetField: "fullName"
        expression: "concat(firstName, ' ', lastName)"
      - targetField: "ageGroup"
        expression: "case when age < 18 then 'minor' else 'adult' end"
      - targetField: "totalCost"
        expression: "quantity * unitPrice * (1 + taxRate)"
```

### 3. Enrichment Transformations

Add data from external sources:

```yaml
transformations:
  - id: "enrichedOrders"
    type: "enrich"
    input: "orderStream"
    enrichmentConfig:
      type: "lookup"
      source:
        type: "jdbc"
        table: "products"
        keyField: "productId"
      fields:
        - name: "productName"
        - name: "category"
        - name: "supplier"
      cacheConfig:
        maxSize: 10000
        expireAfterWrite: "1h"
```

### 4. Split Transformations

Split stream into multiple outputs:

```yaml
transformations:
  - id: "splitByType"
    type: "split"
    input: "sourceStream"
    outputs:
      - name: "purchases"
        condition:
          field: "type"
          operator: "eq"
          value: "purchase"
      - name: "refunds"
        condition:
          field: "type"
          operator: "eq"
          value: "refund"
```

## Advanced Features

### 1. Dynamic Field Generation

Generate fields based on conditions:

```yaml
transformations:
  - id: "dynamicFields"
    type: "map"
    input: "sourceStream"
    dynamicFields:
      - name: "risk_score"
        type: "double"
        expression: |
          case
            when amount > 10000 then 0.9
            when amount > 5000 then 0.7
            when amount > 1000 then 0.5
            else 0.1
          end
```

### 2. Custom Functions

Register and use custom functions:

```yaml
functions:
  - name: "calculateDistance"
    class: "com.gulp.functions.GeoDistance"
    parameters:
      - name: "lat1"
        type: "double"
      - name: "lon1"
        type: "double"
      - name: "lat2"
        type: "double"
      - name: "lon2"
        type: "double"

transformations:
  - id: "enrichedLocations"
    type: "map"
    input: "sourceStream"
    mappings:
      - targetField: "distance"
        expression: "calculateDistance(sourceLat, sourceLon, targetLat, targetLon)"
```

### 3. State Management

Configure state for stateful transformations:

```yaml
transformations:
  - id: "statefulEnrich"
    type: "stateful"
    input: "sourceStream"
    stateConfig:
      backend: "rocksdb"
      ttl: "1h"
      cleanupMode: "full"
    transformConfig:
      type: "accumulate"
      keyBy: ["userId"]
      aggregations:
        - field: "amount"
          operation: "sum"
          window: "1h"
```

## Performance Optimization

### 1. Chain Optimization

```yaml
optimizationConfig:
  chainOptimization:
    enabled: true
    rules:
      - type: "filterPushdown"
        enabled: true
      - type: "projectionPushdown"
        enabled: true
      - type: "predicateMerge"
        enabled: true
```

### 2. Parallelism Configuration

```yaml
transformations:
  - id: "parallelProcess"
    type: "map"
    input: "sourceStream"
    parallelism: 4
    keyBy: ["region", "category"]
    loadBalancing:
      strategy: "key_hash"
      redistributeOnHotKeys: true
```

### 3. Resource Management

```yaml
resourceConfig:
  memory:
    stateSize: "256mb"
    managedMemory: "128mb"
  cpu:
    cores: 2
  network:
    bufferTimeout: "100ms"
    maxBufferSize: "32kb"
```

## Monitoring

### 1. Transformation Metrics

```yaml
monitoring:
  metrics:
    - name: "recordsProcessed"
      type: "counter"
      labels: ["transformation", "type"]
    - name: "processingTime"
      type: "histogram"
      labels: ["transformation"]
    - name: "stateSize"
      type: "gauge"
      labels: ["transformation"]
```

### 2. Alerts

```yaml
monitoring:
  alerts:
    - name: "HighProcessingTime"
      metric: "processingTime"
      threshold: "1s"
      window: "5m"
      severity: "warning"
    - name: "LargeState"
      metric: "stateSize"
      threshold: "1gb"
      severity: "warning"
```

## Error Handling

```yaml
errorConfig:
  retryStrategy:
    maxAttempts: 3
    backoffMultiplier: 2
    initialBackoff: "1s"
  deadLetterQueue:
    enabled: true
    topic: "failed-records"
  errorOutputs:
    - name: "validationErrors"
      condition: "error.type == 'validation'"
    - name: "processingErrors"
      condition: "error.type == 'processing'"
``` 